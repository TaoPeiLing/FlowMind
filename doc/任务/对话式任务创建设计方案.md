# 对话式任务创建设计方案

## 一、对话阶段转换逻辑

### 1. 阶段划分
```ascii
[开放倾诉阶段] 
     │
     ▼
+------------+     +-----------------+
| 驱动力选择 | --> | 开放式问题对话  |
+------------+     +-----------------+
                          │
                          ▼
                   +-----------------+
                   | 情感/意图分析   |
                   +-----------------+
                          │
                          ▼
[温和引导阶段]
     │
     ▼
+------------------+    +------------------+
| 生成引导性问题   | <- | 上下文理解       |
+------------------+    +------------------+
     │
     ▼
+------------------+    +------------------+
| 收集结构化回答   | -> | 动态调整问题     |
+------------------+    +------------------+
     │
     ▼
[任务具象化阶段]
     │
     ▼
+------------------+    +------------------+
| 任务建议生成     | <- | 综合分析         |
+------------------+    +------------------+
     │
     ▼
+------------------+    +------------------+
| 用户确认和调整   | -> | 任务最终化       |
+------------------+    +------------------+
```

### 2. 阶段管理器设计

#### 2.1 对话状态定义
```typescript
interface 对话阶段 {
  阶段: '开放' | '引导' | '具象化';
  当前步骤: number;
  已完成: boolean;
  数据: any;
}

interface 对话状态 extends 对话阶段 {
  驱动力类型?: 驱动力;
  情感数据: {
    显式: 情感数据[];
    隐式: 隐式情感数据[];
  };
  上下文数据: 上下文数据;
}
```

#### 2.2 阶段转换实现
```typescript
class 对话管理器 {
  private async 处理开放倾诉阶段(用户输入: string): Promise<阶段结果> {
    // 1. 记录原始输入
    // 2. 分析驱动力
    // 3. 生成下一步对话
    // 4. 判断是否需要转换阶段
  }

  private async 处理引导阶段(用户输入: string, 上下文: 对话上下文): Promise<阶段结果> {
    // 1. 分析回答
    // 2. 更新对话上下文
    // 3. 生成下一个引导性问题
    // 4. 评估是否完成引导阶段
  }

  private async 处理具象化阶段(上下文: 对话上下文): Promise<任务建议> {
    // 1. 整合所有对话信息
    // 2. 生成任务建议
    // 3. 优化建议
  }
}
```

## 二、情感数据收集方式

### 1. 数据收集流程
```ascii
情感数据收集流程
┌──────────────┐
│ 显式收集     │──┐
└──────────────┘  │
┌──────────────┐  │    ┌──────────────┐    ┌──────────────┐
│ 隐式收集     │──┼───>│ 数据整合     │───>│ 情感分析     │
└──────────────┘  │    └──────────────┘    └──────────────┘
┌──────────────┐  │
│ 行为收集     │──┘
└──────────────┘
```

### 2. 数据结构设计
```typescript
interface 情感数据收集器 {
  // 显式情感数据
  显式: {
    直接表达: string[];
    问题回答: Map<string, string>;
    情感评分: {
      压力值: number;
      信心值: number;
      动力值: number;
    };
  };

  // 隐式情感数据
  隐式: {
    语言模式: {
      情感词: string[];
      强度指标: string[];
      情感得分: number[];
    };
    行为指标: {
      输入速度: number;
      删除率: number;
      停顿时长: number[];
    };
  };

  // 上下文数据
  上下文: {
    时间: string;
    用户历史: {
      近期任务: 任务[];
      情感趋势: 情感趋势[];
    };
    环境因素: {
      设备类型: string;
      位置?: string;
      时区: string;
    };
  };
}
```

## 三、界面实现细节

### 1. 组件层次结构
```ascii
UI组件层次结构
┌─────────────────────────────────────┐
│ 对话容器                           │
├─────────────────────────────────────┤
│ ┌─────────────┐  ┌───────────────┐ │
│ │ 用户输入    │  │ AI响应        │ │
│ └─────────────┘  └───────────────┘ │
│ ┌─────────────────────────────────┐ │
│ │ 情感反馈                        │ │
│ └─────────────────────────────────┘ │
│ ┌─────────────────────────────────┐ │
│ │ 进度指示器                      │ │
│ └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

### 2. 组件设计
```typescript
interface 对话界面组件 {
  // 对话容器
  对话容器: {
    当前阶段: 对话阶段;
    进度: number;
    子组件: ReactNode;
  };

  // 用户输入组件
  用户输入: {
    类型: '文本' | '选择' | '评分';
    提示文本: string;
    建议?: string[];
    情感反馈?: boolean;
  };

  // AI响应组件
  AI响应: {
    消息: string;
    类型: '问题' | '建议' | '确认';
    情感基调: 情感基调;
    视觉提示?: 视觉元素[];
  };

  // 情感反馈组件
  情感反馈: {
    当前情感: 情感;
    强度: number;
    建议: string[];
    反馈处理: (反馈: 情感反馈) => void;
  };

  // 进度指示器
  进度指示器: {
    阶段列表: 对话阶段[];
    当前阶段: 对话阶段;
    进度: number;
    里程碑: 里程碑[];
  };
}
```

### 3. 设计原则

#### 3.1 渐进式揭示
- 每个阶段只显示必要的信息
- 通过动画平滑过渡
- 提供清晰的进度反馈

#### 3.2 情感响应式设计
- 根据用户情感状态调整界面风格
- 提供适当的视觉反馈
- 使用恰当的色彩和动画

#### 3.3 交互流畅性
- 确保输入响应及时
- 提供适当的加载状态
- 支持撤销和修改操作

## 四、实现注意事项

1. 对话流程控制
   - 确保每个阶段的转换逻辑清晰
   - 保持对话的自然性和连贯性
   - 提供适当的回退机制

2. 情感数据处理
   - 注意数据收集的实时性
   - 确保情感分析的准确性
   - 保护用户隐私数据

3. 界面交互优化
   - 保持界面简洁直观
   - 优化响应速度
   - 提供必要的帮助信息
