# 心流 - 版本管理策略

## 一、版本号规范

### 1. 版本号格式
采用语义化版本号（Semantic Versioning）：`主版本号.次版本号.修订号`
- 例如：1.2.3

### 2. 版本号递增规则
- **主版本号**：当进行不兼容的 API 修改时
- **次版本号**：当添加功能时（向下兼容）
- **修订号**：当进行向下兼容的缺陷修复时

### 3. 预发布版本标识
- Alpha版本：`1.2.3-alpha.1`
- Beta版本：`1.2.3-beta.1`
- RC版本：`1.2.3-rc.1`（Release Candidate）

## 二、分支管理策略

### 1. 主要分支
- **main**：主分支，稳定版本
- **develop**：开发分支，最新开发版本

### 2. 辅助分支
- **feature/***：功能分支
  - 命名规范：`feature/功能名称`
  - 基于develop分支创建
  - 完成后合并回develop分支

- **release/***：发布分支
  - 命名规范：`release/版本号`
  - 基于develop分支创建
  - 完成后同时合并到main和develop

- **hotfix/***：热修复分支
  - 命名规范：`hotfix/问题描述`
  - 基于main分支创建
  - 完成后同时合并到main和develop

### 3. 分支生命周期
1. **功能分支**
   - 创建：开始新功能开发时
   - 合并：功能完成并测试通过
   - 删除：合并完成后

2. **发布分支**
   - 创建：版本发布准备阶段
   - 合并：版本测试通过后
   - 删除：合并完成后

3. **热修复分支**
   - 创建：发现线上紧急问题
   - 合并：修复完成并测试通过
   - 删除：合并完成后

## 三、提交信息规范

### 1. 提交信息格式
```
<类型>(<范围>): <描述>

[可选的正文]

[可选的脚注]
```

### 2. 提交类型
- **feat**: 新功能
- **fix**: 修复缺陷
- **docs**: 文档更新
- **style**: 代码格式调整
- **refactor**: 代码重构
- **perf**: 性能优化
- **test**: 测试相关
- **chore**: 构建/工具链/辅助工具的变动

### 3. 范围说明
- **core**: 核心功能
- **ui**: 界面相关
- **api**: API相关
- **auth**: 认证相关
- **data**: 数据相关
- **deps**: 依赖相关

## 四、发布流程

### 1. 版本发布步骤
1. 从develop分支创建release分支
2. 在release分支进行版本相关调整
3. 测试验证
4. 合并到main分支并打标签
5. 同时合并回develop分支
6. 删除release分支

### 2. 热修复发布步骤
1. 从main分支创建hotfix分支
2. 在hotfix分支进行修复
3. 测试验证
4. 合并到main分支并打标签
5. 同时合并回develop分支
6. 删除hotfix分支

### 3. 版本标签管理
- 标签命名：v版本号
- 例如：v1.2.3
- 包含版本描述信息
- 为每个正式发布版本打标签

## 五、代码评审规范

### 1. 评审重点
- 代码质量
- 测试覆盖
- 文档完整性
- 性能影响
- 安全隐患

### 2. 评审流程
1. 提交合并请求
2. 指定评审人
3. 评审人反馈
4. 修改完善
5. 评审通过
6. 合并代码

## 六、持续集成/持续部署

### 1. CI/CD流程
1. 代码提交触发自动构建
2. 运行自动化测试
3. 代码质量检查
4. 生成构建产物
5. 自动部署到测试环境
6. 人工确认后部署到生产环境

### 2. 环境管理
- **开发环境**：开发人员使用
- **测试环境**：QA测试使用
- **预发环境**：生产环境的镜像
- **生产环境**：最终用户使用

## 七、版本管理工具

### 1. 必要工具
- Git：版本控制系统
- GitLab/GitHub：代码托管平台
- CI/CD工具：Jenkins/GitLab CI
- 代码质量工具：ESLint/SonarQube

### 2. 辅助工具
- 自动化测试工具
- 代码评审工具
- 文档管理工具
- 项目管理工具

## 八、应急预案

### 1. 版本回滚机制
- 保留回滚所需的配置和数据
- 制定详细的回滚步骤
- 定期演练回滚流程

### 2. 紧急修复流程
1. 确认问题影响范围
2. 创建热修复分支
3. 修复并测试
4. 部署修复版本
5. 更新文档和记录

## 九、文档维护

### 1. 必要文档
- 版本发布说明
- API文档
- 数据库变更记录
- 配置变更记录

### 2. 文档更新时机
- 版本发布前
- 重要变更后
- 问题修复后
- 定期回顾和更新 

## 十、子模块管理

### 1. 项目结构
- **前端子模块**：`frontend/`
- **后端主仓库**：项目根目录

### 2. 子模块管理规范
1. **代码提交流程**
   - 前端代码修改需要在 `frontend` 目录中单独提交
   - 主仓库需要更新子模块的引用
   - 确保子模块的变更被正确追踪

2. **提交顺序**
   ```bash
   # 1. 在子模块中提交更改
   cd frontend
   git add .
   git commit -m "feat: 功能描述"
   cd ..

   # 2. 在主仓库中更新子模块引用
   git add frontend
   git commit -m "chore: 更新前端子模块"
   ```

3. **分支管理**
   - 子模块应保持与主仓库相同的分支结构
   - 功能开发时应同时在主仓库和子模块中创建对应分支

### 3. 注意事项
- 克隆项目时需要使用 `git clone --recursive` 获取子模块代码
- 拉取更新时需要同时更新子模块 `git pull && git submodule update`
- 切换分支时需要注意子模块的状态

### 4. 子模块优势
- 前后端代码解耦
- 独立的版本控制
- 更清晰的项目结构
- 便于团队协作